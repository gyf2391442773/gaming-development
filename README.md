# gaming-development
white‘s fist Sept
SFML gaming Development & Design
游戏地图是游戏的必要元素之一，而随机游戏地图的出现可以大大提高游戏的可玩性和乐趣。但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。针对上述的问题，对随机地图的生成做了研究，做出一个可拓展的随机地图生成器，可以生成不同风格的随机地图，并且针对这个随机地图生成器，基于C++和SFML库做出了一个简单的Roguelike游戏的demo。

随机生成的游戏地图是Roguelike类游戏最独特的一点，它往往也是吸引玩家的要素之一，因为玩家随时都面临着未知的挑战。传统思路中的随机游戏地图生成方式基本可以概括为填充、元胞自动机、构建连通图三步。而我们的此次的研究目标为：学习如何生成随机地图，做出可拓展的随机地图生成器；学习基础游戏逻辑，做出一套基础可拓展的游戏内元素；利用简单的图形库，实现简单的Roguelike游戏。
        传统的元胞自动机（Cellular Automaton）的思路一般是在一个二维数组内，以一点为中心，遍历周围三乘三的范围的数据，若“墙”的数量大于等于五个则中心数据为“墙”，反之为“地”。如图2-1，这种方式经过多次迭代之后可以得到零散的几个较大范围的“区域”，所以一般会在接着构建连通图，但思路并非唯一。

	本次研究过程中，我们了解到另一种元胞自动机，其思路是在一个二维数组内，以一点为中心，遍历周围五乘五的范围的数据，去掉四个顶点后，对N圈内的“墙”的数量进行判断，若一圈内“墙”的数量大于等于5或两圈内“墙”的数量小于等于2，则中心数据为“墙”，反之为“地”。如图2-2，这种元胞自动机经过4到5次的迭代后可以生成一整片较大的“区域”，于是我们使用了这种元胞自动机先生成一个地图轮廓，再用传统思路迭代3到4次以达到平滑地图的目的。但即便是这样操作依然还会有概率生成不连通的“区域”。
 
非连通区域消除算法（非递归洪水填充）
	在以往的过程中，处理非连通区域的方法往往是用各种方式构建连通图，但我们此次使用两种元胞自动机生成的地图轮廓完全足够使用，于是我们没用构建连通图，而是选择去除非连通区域。
	去除非连通区域的算法可以分为统计与填充两部分。
对于统计部分，我们使用了非递归的洪水填充算法。集体思路为，按照一定顺序遍历地图数组，当遍历到第一个“地”时，进入算法，将该“地”做标记M（M为第M个区域），并使其入队列，接着进入循环，循环终止条件为队列为空，在循环内，分别让对应位置的上、下、左、右元素中为“地”的位置入队列，判断完后让中心位置出队列，直至内外循环结束。
上述算法可以很快将所有连通区域标记，若在元素入队列的统计记录对应区域的面积即可得知各区域的面积，最后仅保留面积最大的区域，将剩下的区域填充即可。
如图2-3，去除非连通区域后，我们又对内部的过小的墙体进行了删减，已到达想要的效果，具体方法是重用上述的算法，仅需将“墙”“地”的判断互换，再将对区域面积进行特判即可。

游戏概述
	为了展示地图生成的效果，本项目针对BigCave类地图设计了一个游戏demo，游戏完全基于C++与SFML，全部从最底层一步一步构建。该游戏的代码具有完整的类结构和丰富的类功能，后续开发只需调用已有的类即可。
游戏demo只有一关的内容，玩家击杀所有怪物或玩家死亡则游戏结束，并自动进行下一局游戏。

游戏逻辑
	从设计一个简单的游戏的角度出发，了解基本的游戏逻辑是很有必要的，因为游戏逻辑可以让我们清楚的知到在某一个时间点，程序应该干什么。
	一个基本的游戏逻辑可以用一个简单的循环来表示，循环在游戏运行时始终运行，循环内部分为两个部分：update和render。update部分为更新部分，负责按顺序更新游戏内的各种元素，包括各个实体的位置、角度和状态等。render部分为渲染部分，负责将更新后的各元素按照顺序渲染在屏幕的指定位置上。

游戏场景的生成
	游戏世界或世界中的某些部分是随机生成的。这里可以包括地形、怪物出现的位置等。随机生成的好处就是可以提高重复游戏性。
	在游戏的初始化过程中，我们首先加载了随机生成的地图，然后，将人物放置在对应的位置，最后遍历地图中的元素，随机选取位置生成怪物。，以达到随机生成的目的。

动画的实现
	图形库只能加载图形、图片，但如果想要实现动画，如图4，可以采用快速更换图片的方式。我们在构建动画的时候，有三个重要参数：Frame、speed、framecount。这三个参数分别储存当前图片、图片的更换速度、总图片数。在实现的时候，只需要让Frame在每次更新循环中加上speed即可实现动画，若想使动画循环，只需要在Frame大于等于framecount时令Frame减去framecount即可。

怪物状态与移动逻辑
怪物状态目前有三种：空闲状态、攻击状态和受击状态。
1)	空闲状态，是怪物的初始化状态，主要进行小范围游离态的随机移动；
2)	攻击状态，当玩家出现在怪物视野范围内，则会激活此状态，怪物开始攻击玩家并进入暴走模式，朝着玩家进行有目的性的随机移动；
3)	受击状态，即怪物受到攻击的一种状态，主要有受击动画，受击反馈。
对于怪物的移动逻辑，空闲时的移动逻辑通过设置范围和随机的位移实现。攻击状态的暴走模式是一种有目的性的随机移动，位移方向无非有两种，靠近玩家和远离玩家，利用随机数设置这两种移动方向的概率，使怪物更大可能靠近玩家。确定移动方向，还需一个随机Key值决定怪物的移动幅度，最后根据移动幅度给予怪物一个速度，移动幅度越大速度则应越快。

子弹生成
	游戏中，每一颗子弹都是独立的实体。我们采用list来存储每一颗子弹。在子弹生成时，只需新建对应类型的指针插入list中，而在后续更新过程中对list中的所有对象循环遍历判断，将部分满足删除条件的子弹从list中删除即可。
